#pragma kernel MainCS

#include "UnityCG.cginc"

// スレッドグループのスレッドサイズ
#define ThreadBlockSize 32//64//256


// data
struct HitTestData
{
    float3 position;
    float3 velocity;
    int index;
    float time;
};

RWStructuredBuffer<HitTestData> _HitTestDataBuffer;//_DokabenDataBuffer;
RWStructuredBuffer<float3> _Result;//_DokabenDataBuffer;

//Texture2D<float4> _ColorTex;
//float _Far;

float rand(float3 co)
{
    return frac(sin(dot(co.xyz, float3(12.9898, 78.233, 45.5432))) * 43758.5453);
}
			
float rand(float2 co)
{
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

[numthreads(ThreadBlockSize, 1, 1)]
void MainCS(uint3 id : SV_DispatchThreadID)
{
    
    const unsigned int index = id.x;

    float3 pos = _HitTestDataBuffer[index].position;
    HitTestData data =_HitTestDataBuffer[index];

    //反発力を計算する

    for(int i=0;i<1024;i++){

        if(i!=index){
            float3 d = data.position - _HitTestDataBuffer[i].position;

            float r = length(d)/2;
            r = min(r,1);
            r = 1 - r;

            data.velocity.x += 0.02 * d.x * r;
            data.velocity.y += 0.02 * d.y * r;
            data.velocity.z += 0.02 * d.z * r;
            
        }

    }

    data.velocity.x *= 0.9f;
    data.velocity.y *= 0.9f;
    data.velocity.z *= 0.9f;

    data.position += data.velocity;


    data.time += 0.01;

    //_Result[index].y = sin( data.time );
    //data.position.y = 5*sin( data.time );
    
    _Result[index] = data.position;
    _HitTestDataBuffer[index]=data;


}